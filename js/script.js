// --------------------- SELE√á√ÉO DE ELEMENTOS -------------------------------

/*
InputAddNota: Input onde o usu√°rio digita a nota que quer adicionar(retornar√° como texto da nota)

InputPesquisa: Input onde o usu√°rio digita a nota que ele quer pesquisar(retornar√° como texto para filtrar as notas)

btnAddNota: Bot√£o que o usu√°rio clica para ent√£o add a nota

sectionNotas: Elemento HTML onde vai ser colocado todas as nossas representa√ß√µes DOM das notas
*/
const inputAddNota = document.getElementById('iAddNota');
const inputPesquisa = document.getElementById('iPesquisa');
const btnAddNota = document.getElementById('btnAddNota');
const sectionNotas = document.querySelector('.notasAdd');



// ----------------------------- STORAGE ------------------------------------

/*
Fun√ß√£o tem duas partes, a primeira √© a nossa cria√ß√£o do localStorage, nos damos uma nome "DevNotes" que √© o nome da nossa aplica√ß√£o dentro do storage e ent colocamos a devolutiva dentro da variavel "notas", essa fun√ß√£o tem que retornar ou as notas que est√£o salvas no LocalStorage em forma de obj JSON, ou caso n√£o tenha, retorne uma array vazia para come√ßarmos a aplica√ß√£o.
*/
function pegarNotasStorage(){
    const notas = localStorage.getItem('DevNotes');
    return notas ? JSON.parse(notas) : [];
}

/*
salvarNotasStorage vai receber uma array de obj, onde a gente vai setar essa array dentro do nosso storage, a gente j√° nomeiou o lugar que vai ser guardado nossas notas "DevNotes", e ent vamos colocar l√° caso for a primeira itera√ß√£o ent a primeira nota, caso n√£o ,ent seria mais um atualiza√ß√£o de um "banco de dados" do navegador, e claro temos que tranformar a array de obj json para string
*/
function salvarNotasStorage(notas){
    localStorage.setItem('DevNotes', JSON.stringify(notas));
}



// ---------------------------- RENDERIZA√á√ÉO --------------------------------
/*
Fun√ß√£o para renderizar as notas que est√£o no localStorage, caso aja alguma nota armazenada l√°. Temos dois tipo diferentes de renderiza√ß√£o, uma √© quando a chamamos sem parametro, que no caso ela ent√£o pega as notas que est√£o salvas no LocalStorage caso aja, e ent cria seu html e a outra √© para quando tivermos uma array de notas filtradas, e ent pegamos essas notas filtradas e criamos seu HTML.
*/
function renderizarNotas(notasFiltradas = null){
    const notas = notasFiltradas || pegarNotasStorage();

    sectionNotas.innerHTML = '';

    notas.forEach(nota => {
        const divNota = document.createElement('div');
        divNota.classList.add('nota');
        divNota.dataset.id = nota.id;

        divNota.innerHTML = `
        <p>${nota.texto}</p>
        <div class="acoesNota">
            <button class="btnEditar">‚úèÔ∏è</button>
            <button class="btnRemover">üóëÔ∏è</button>
            <button class="btnFixar">üìå</button>
            <button class="btnCopiar">üìã</button>
        </div>
        `;

        sectionNotas.appendChild(divNota);
    });
}



// -------- Fun√ß√µes das Notas --------
/*
A fun√ß√£o adicionarNota se relaciona com a de renderizarNotas, essa fun√ß√£o cuida da parte de dados, da cria√ß√£o de obj nota para colocar dentro de uma array que ent ser√° colocado e salvo dentro do localStorage, criamos a parte real digamos, os dados em s√≠, para que usemos esses dados para conseguirmos tranformar o abstrato em algo visual, que √© a parte DOM. Essa aqui √© a primeira fun√ß√£o que √© chamada quando o usu√°rio clica no btn de add a nota
*/
function adicionarNota(){
    const textoNota = inputAddNota.value.trim();
    if(textoNota === '') return;

    const notas = pegarNotasStorage();
    const novaNota = {
        id: Date.now().toString(),
        texto: textoNota,
        fixada: false
    };

    notas.push(novaNota);
    salvarNotasStorage(notas);

    inputAddNota.value = '';
    renderizarNotas();
}

//------------------- FUN√á√ïES PARA MANIPULA√á√ÉO DE NOTAS ---------------------

/*
Essa fun√ß√£o removerNota recebe o id do datasetId do container da nota especifica, n√≥s precisamos pegar as notas que est√£o no nosso arm√°rio(localStorage) e n√≥s vamos fazer um retorno de uma nossa array de notas onde a nota em quest√£o que √© o id que foi passado n√£o esteja. ".filter()" √© um metodo que filtra array com base em uma condi√ß√£o, "n => n.id != id" aqui n √© cada obj dentro da array, a gente vai no id de cada obj e vai ver se ele √© diferente do id(datasetId) que foi passado, se for ent ele retorna esse obj para array, se n√£o diferente ent significa que estamos falando com o obj que queremos remover, ent ele n√£o √© retornado. N√≥s ent agora temos uma nova array sem o obj que n√£o queremos mais, a gente salva no nosso arm√°rio essa nova array, e ent recria o DOM com os OBJ que ficaram.
*/
function removerNota(id){
    let notas = pegarNotasStorage();
    notas = notas.filter(n => n.id != id);
    salvarNotasStorage(notas);
    renderizarNotas();
}


/*
copiarNota recebe o id que foi passado pela fun√ß√£o botaoClicado, que √© o id do container que contem o btn que foi clicado, pegamos as notas no nosso armario(localStorage), filtramos a notaOriginal foi queremos pegar o texto dela, usamos o metodo ".find()" que retorna apenas a primeira ocorrencia daquela condi√ß√£o, criamos outro obj que vai ser a copia do obj original. Todas as notas s√£o objs dentro de uma array, para acessarmos um elemento dentro de uma array usamos os indices(0 √© o primeiro elemento, 1 o segundo e assim vai), queremos que essa copia seja add logo ap√≥s a original, ent vamos usar os indices, pegamos ent o indice da nota original com o metodo ".findIndex()" para ser usado no splice um metodo que add, remove ou subtitui um elemento em uma array, contendo 3 parametros, o primeiro √© a partir de que indice ele vai remover,add,subtituir, um elemento, o segundo se for 0 significa que n√£o vamos remover nada, se for 1 remover 1 elemento a partir do indice que indicamos e assim por diante, e o terceiro √© o opcional caso queremos add um elemento da array, que √© a copia do obj, n√≥s ent salvamos essa nova array, e ent fazemos o dom dessa nova array.
*/
function copiarNota(id){
    const todasNotas = pegarNotasStorage();
    const notaOriginal = todasNotas.find(n => n.id == id);
    if(!notaOriginal) return;

    const novaNota = {
        id: Date.now().toString(),
        texto: notaOriginal.texto,
        fixada: false
    }

    const indiceOriginal = todasNotas.findIndex(n => n.id == id);
    todasNotas.splice(indiceOriginal + 1, 0, novaNota);
    salvarNotasStorage(todasNotas);
    renderizarNotas();  
}


/*
Primeiro temos que filtrar a nota que queremos Editar no sentido DADO, DEPOIS N√≥s queremos mudar o paragrafo que est√° dentro de um container DIV, isso √© parte DOM, ent vamos no container que contem todas as notas que tem a class ".nota" e vamos no datasetId dele e colocamos o id que n√≥s foi passado que √© a nota que queremos editar, a√≠ selecionamos o p, criamos um textArea colocando nesse o valor que j√° est√° na notaOriginal, damos uma class, e trocamos o p pelo textArea.

Demos uma class para o textArea pois √© depois de o usu√°rio sair do textArea, que ent agora tem que rolar uma atualiza√ß√£o na quest√£o do obj que teve seu texto alterado, ent no textArea usamos o evento blur, que √© disparado quando o textArea sair do foco ou seja o usu√°rio sair dele, a√≠ n√≥s vamos l√° no obj que pegamos da notaParaEditar e no texto dele colocamos o que tem agora no textArea, salvamos e ent renderizamos o DOM(visual) com um novo texto na nota(OBJ)
*/
function editarNota(id){
    const todasNotas = pegarNotasStorage();
    const notaParaEditar = todasNotas.find(n => n.id == id);
    if(!notaParaEditar) return;

    const divNota = document.querySelector(`.nota[data-id="${id}"]`);
    if(!divNota) return;

    const pTexto = divNota.querySelector('p');
    const textAreaEdicao = document.createElement('textarea');
    textAreaEdicao.value = notaParaEditar.texto;
    textAreaEdicao.classList.add('textAreaEdicao');

    divNota.replaceChild(textAreaEdicao, pTexto);

    textAreaEdicao.addEventListener('blur', () => {
        notaParaEditar.texto = textAreaEdicao.value.trim();
        salvarNotasStorage(todasNotas);
        renderizarNotas();
    });

    textAreaEdicao.addEventListener('keypress', (e) => {
        if(e.key === 'Enter'){
            e.preventDefault();
            textAreaEdicao.blur();
        }
    });

    textAreaEdicao.focus();
}


/*
FixarNota ent pega a nota que √© para ser Fixada, muda o estado Booleando do atributo fixada, vai em todas as notas e ordena elas co base no metodo de ordenamento ".sort()" que faz uma compara√ß√£o entre dois obj, vai no atributo fixada deles que √© booleano ent retorna 0(n√£o fixada) 1(fixada) e faz uma compara√ß√£o que vai ter como volta 0 que deixa os obj do jeito que est√°, um numero maior que 0 que faz com que o obj b venha depois do obj a, e se der negativo o obj a vem antes do obj b, salvamos a nova array com o novo ordenamento, e renderizamos o DOM novamente
*/
function fixarNota(id){
    const todasNotas = pegarNotasStorage();
    const notaFixar = todasNotas.find(n => n.id == id);
    if(!notaFixar) return;

    notaFixar.fixada = !notaFixar.fixada;

    // Ordena para mostrar fixadas primeiro
    todasNotas.sort((a,b) => b.fixada - a.fixada);

    salvarNotasStorage(todasNotas);
    renderizarNotas();
}

// ------------------ BOT√ÉO CLICADO (EVENT DELEGACION) ----------------------

/*
botaoClicado √© uma fun√ß√£o com o propr√≥sito de pegarmos o id daquele container onde cont√©m o bot√£o que foi clicado, para ent√£o sabermos que bot√£o em que container podemos mexer, primeiro n√≥s usamos o obj de evento que o navegador n√≥s d√°, "e.target" retorna que elemento o usuario clicou, que no caso vai retornar um bot√£o, ".closest(.nota) n√≥s precisamos de um id para identificador que obj, container, de nota foi clicado certo? ent o closest sobe na hieraquia DOM a partir do elemento que foi clicado at√© ele achar um elemento com a class .nota, que √© o container das notas, ent ele acha o container do btn que foi clicado e pagamos o datasetId desse container que √© o mesmo id do obj de quando ele foi criado!"
*/
function botaoClicado(e){
    const notaId = e.target.closest('.nota')?.dataset.id;
    if(!notaId) return;

    if(e.target.classList.contains('btnRemover')){
        removerNota(notaId);
    } else if(e.target.classList.contains('btnEditar')){
        editarNota(notaId);
    } else if(e.target.classList.contains('btnCopiar')){
        copiarNota(notaId);
    } else if(e.target.classList.contains('btnFixar')){
        fixarNota(notaId);
    }
}

// ---------------------------- PESQUISA ------------------------------------

/*
Aqui a logica inclui o metodo ".includes()" e o textoPesquisa, vamos no arm√°rio(localStorage) pegamos a notas e filtramos ela com base no seguinte, se o texto daquela nota inclui o texto da pesquisa, ent ele retorna a nota em quest√£o, e ent chamamos a fun√ß√£o de renderizarNotas s√≥ que dessa vez com parametro, o parametro √© as notasFiltradas, essas notasFiltradas v√£o ser colocadas na variavel notas do renderizar e ent seguir o fluxo da fun√ß√£o
*/
function pesquisarNotas(){
    const todasNotas = pegarNotasStorage();
    const textoPesquisa = inputPesquisa.value.trim().toLowerCase();

    const notasFiltradas = todasNotas.filter(nota => 
        nota.texto.toLowerCase().includes(textoPesquisa)
    );

    renderizarNotas(notasFiltradas);
}

// ------------------------------ EVENTOS -----------------------------------


/*
Evento de clique colocado no btn de add nota, esse evento chama a fun√ß√£o de adicionarNota que cria o obj de nota coloca dentra da array salva, e a√≠ chama o renderizarNota para criar o DOM, esse evento desencadeia 4 fun√ß√µes, adicionarNota, renderizarNota, salvarNotaStorage, PegarNotaStorage, um chamando o outro
*/
btnAddNota.addEventListener('click', adicionarNota);


/*
Evento de Keypress na input de add nota para caso de o usuario n√£o clicar no btn e apertar enter
 */
inputAddNota.addEventListener('keypress', (e) => {
    if(e.key === 'Enter'){
        adicionarNota();
    }
});


/*
PAI de todas as notas em quest√£o do DOM, ele atraves do event delegacion OUVE os cliques nos seus filhos e ent chama a fun√ß√£o botaoClicado que vai pegar o id e passar para os botoes vendo qual foi escolhido(editar,remover,copiar,fixar)
*/
sectionNotas.addEventListener('click', botaoClicado);


/*
Evento de input na input de pesquisa que chama pesquisarNotas, que pega o texto da input percorre todas as notas e ve se no texto dela inclui o texto digitado na input
*/
inputPesquisa.addEventListener('input', pesquisarNotas);


// ---------------------------- INICIALIZA√á√ÉO -------------------------------


/*
Fun√ß√£o para renderizar a parte visual, ou seja a parte DOM, a aquest√£o HTML das notas que j√° est√£o armazenadas no localStorage
*/
renderizarNotas();
